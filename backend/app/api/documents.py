from flask import Blueprint, request, jsonify, current_app, send_file
from flask_jwt_extended import jwt_required, get_jwt_identity
from app import db
from app.models import GeneratedDocument, User
from app.services.document_generation import generate_document_llm
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.enums import TA_CENTER
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
import os
import io
from datetime import datetime

documents_bp = Blueprint('documents', __name__)

@documents_bp.route('/generate-document', methods=['POST'])
@jwt_required()
def generate_document():
    current_user_id = get_jwt_identity()
    user = User.query.get(current_user_id)
    if not user:
        return jsonify({"message": "User not found"}), 404

    data = request.json
    document_type = data.get('document_type')
    inputs = data.get('inputs')

    if not document_type or not inputs:
        return jsonify({"message": "Missing document_type or inputs"}), 400

    # RAG: Retrieve relevant context based on inputs
    # Use a simple combination of inputs as the query for now
    rag_query = f"{inputs.get('title', '')} {inputs.get('event_name', '')} {inputs.get('department', '')} {inputs.get('details', '')}"
    rag_context_chunks = []
    rag_context_ids = []
    
    if rag_query.strip():
        try:
            from app.services.embedding_service import get_embeddings_for_query
            relevant_embeddings = get_embeddings_for_query(rag_query, top_k=current_app.config['RAG_TOP_K'])
            rag_context_chunks = [item['text_chunk'] for item in relevant_embeddings]
            rag_context_ids = [item['id'] for item in relevant_embeddings]
        except Exception as rag_error:
            current_app.logger.warning(f"RAG retrieval failed, continuing without RAG context: {rag_error}")
            # Continue without RAG context - fallback template will be used

    try:
        generated_text = generate_document_llm(document_type, inputs, rag_context_chunks)
    except Exception as e:
        current_app.logger.error(f"LLM generation failed: {e}")
        return jsonify({"message": "Failed to generate document with LLM", "error": str(e)}), 500

    new_document = GeneratedDocument(
        title=inputs.get('title', f'{document_type} - {datetime.now().strftime("%Y%m%d%H%M%S")}'),
        document_type=document_type,
        generated_by=current_user_id,
        content=generated_text,
        admin_inputs=inputs,
        rag_context_ids=rag_context_ids
    )
    db.session.add(new_document)
    db.session.commit()

    return jsonify({"message": "Document generated successfully", "document_id": new_document.id, "generated_text": generated_text}), 201

@documents_bp.route('/documents/history', methods=['GET'])
@jwt_required()
def get_documents_history():
    current_user_id = get_jwt_identity()
    # Fetch documents generated by the current user
    history = GeneratedDocument.query.filter_by(generated_by=current_user_id).order_by(GeneratedDocument.generation_date.desc()).all()

    output = []
    for doc in history:
        output.append({
            "id": doc.id,
            "title": doc.title,
            "document_type": doc.document_type,
            "generation_date": doc.generation_date.isoformat(),
            "status": doc.status
        })
    return jsonify(output), 200

@documents_bp.route('/documents/<int:doc_id>', methods=['GET'])
@jwt_required()
def get_document_details(doc_id):
    current_user_id = get_jwt_identity()
    document = GeneratedDocument.query.filter_by(id=doc_id, generated_by=current_user_id).first()

    if not document:
        return jsonify({"message": "Document not found or unauthorized"}), 404

    return jsonify({
        "id": document.id,
        "title": document.title,
        "document_type": document.document_type,
        "generation_date": document.generation_date.isoformat(),
        "content": document.content,
        "admin_inputs": document.admin_inputs,
        "rag_context_ids": document.rag_context_ids,
        "status": document.status,
        "pdf_filepath": document.pdf_filepath
    }), 200

@documents_bp.route('/documents/<int:doc_id>/pdf', methods=['GET'])
@jwt_required()
def download_document_pdf(doc_id):
    current_user_id = get_jwt_identity()
    document = GeneratedDocument.query.filter_by(id=doc_id, generated_by=current_user_id).first()

    if not document:
        return jsonify({"message": "Document not found or unauthorized"}), 404

    # Generate PDF dynamically
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    
    # Custom style for title
    title_style = ParagraphStyle(
        name='CustomTitle',
        parent=styles['h1'],
        fontSize=18,
        leading=22,
        alignment=TA_CENTER,
        spaceAfter=14
    )
    # Custom style for document type
    doc_type_style = ParagraphStyle(
        name='CustomDocType',
        parent=styles['h2'],
        fontSize=14,
        leading=16,
        alignment=TA_CENTER,
        spaceAfter=12,
        textColor='gray'
    )
    # Custom style for content
    content_style = ParagraphStyle(
        name='CustomContent',
        parent=styles['Normal'],
        fontSize=10,
        leading=14,
        spaceAfter=8,
    )


    story = []
    story.append(Paragraph(document.title, title_style))
    story.append(Paragraph(document.document_type.upper(), doc_type_style))
    story.append(Spacer(1, 0.2 * 1.5 * 10)) # 0.2 inch spacer

    # Add generation metadata
    story.append(Paragraph(f"<b>Date:</b> {document.generation_date.strftime('%Y-%m-%d')}", styles['Normal']))
    story.append(Paragraph(f"<b>Department:</b> {document.admin_inputs.get('department', 'N/A')}", styles['Normal']))
    story.append(Spacer(1, 0.2 * 10))

    # Add content
    for paragraph_text in document.content.split('\n\n'): # Split by double newlines for paragraphs
        if paragraph_text.strip():
            story.append(Paragraph(paragraph_text.strip(), content_style))
            story.append(Spacer(1, 0.1 * 10)) # Small spacer between paragraphs

    doc.build(story)

    buffer.seek(0)
    
    filename = f"{document.title.replace(' ', '_')}_{document.document_type.replace(' ', '_')}.pdf"
    return send_file(buffer, as_attachment=True, download_name=filename, mimetype='application/pdf')
